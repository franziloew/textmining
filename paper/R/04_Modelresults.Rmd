---
title: "Model Results"
subtitle: ""
author: "Franziska Löw"
date: ""
output: 
  html_document:
    theme: "lumen"
    highlight: "tango"
    code_folding: show
    self_contained: true
---

```{r include=FALSE}
library(ggplot2)     # Static data visualization
library(dplyr)       # Data manipulation
library(stringr)     # String manipulation
library(lubridate)   # Date and time manipulation
library(purrr)       # Functional programming
library(tidyr)       # Reshaping
library(magrittr)    # Advanced piping
library(pushoverr)   # Pushover notifications
library(readr)       # Importing data
library(data.table)
library(stm)
library(readxl)
library(Matrix)

library(igraph)
library(corrplot)
library(patchwork)
library(ggpmisc)
library(ggraph)
library(ggiraph)
library(tidygraph)
library(RColorBrewer) 
library(ggrepel)
library(scales)      # Scales
library(viridis)     # Viridis color scales

library(tidytext)    # Tidy text mining
library(stringdist)  # String distances
library(proxy)       # Distance measures

# Theming
quartzFonts(
  Roboto =
    c("Roboto-Light",
      "Roboto-Bold",
      "Roboto-Regular",
      "Roboto-Thin")
)

theme_set(
  theme_bw(base_family = "Roboto", base_size = 8) +
    theme(
      plot.title = element_text(size = 10,
                                margin = margin(0, 0, 4, 0, "pt")),
      plot.subtitle = element_text(size = 12),
      plot.caption = element_text(size = 6),
      plot.background   = element_rect("#fafafa", "#fafafa"),
      panel.background  = element_rect("#fafafa"),
      panel.border = element_blank()
    )
)

rm(list=ls())
col <- brewer.pal(6,"Dark2")
source("func/functions.R")
```

# 2. Data 
```{r caching, echo = FALSE}
load("../output/btw_out.Rda")
```

## Distribution of articles
```{r message=FALSE, warning=FALSE}
ggsave({
  btw %>%
  ggplot(aes(site)) +
  geom_bar(fill=col[1], alpha= .8) +
  labs(x="", y="Number of articles") +
  theme(
      legend.position   = "none"
    )
  
},
filename = "../figs/bar.png", device = "png", 
width = 6, height = 4,
        dpi = 600)
```

```{r message=FALSE, warning=FALSE}
ggsave({
  btw %>%
  group_by(date) %>%
  dplyr::summarise(obs = n()) %>%
  ggplot(aes(date, obs)) +
  geom_line(color=col[3]) +
  geom_vline(aes(xintercept=as.Date("2017-09-24")),
             linetype = 2, color=col[2]) +
  scale_color_manual(values = col) +
  labs(x="", y="number of articles",color="") +
  scale_x_date(breaks = date_breaks("1 month"), labels=date_format("%B", tz="CET")) +
  theme(
      legend.position   = "none",
      axis.title.x      = element_blank(),
      axis.text       = element_text(size = 8)
    )
},
filename = "../figs/timeline.png", device = "png",width = 6, height = 4,
dpi = 600
)

```

# 3. Model Results
```{r echo = FALSE}
load("../output/models/STM 35 .Rda")
k <- stmOut$settings$dim$K
```

## Label topics
```{r}
sagelabs <- sageLabels(stmOut, 20)
```

```{r}
stmOut$settings$covariates$yvarlevels
```

### Label topics based on Bild.de

After reviewing a sample of articles assigned to the respective topic, we assign a shorter name to the topics based on the most common words in order to improve readability and traceability.
```{r}
sagelabs$cov.betas[[1]]$problabels[,1:5]
```

```{r}
topics <- matrix(c(1, "SPD, M.Schulz", 2, "A.Merkel vs. Schulz", 3, "Jamaica coalition", 4, "Diesel scandal", 
                   5, "H.Kohl", 6, "Federal Elections", 7, "EU policies, refugees", 8, "Political trends in GER", 
                   9, "AfD in Parliament", 10, "A.Merkel", 11, "Deportation, radicalization, refugees", 
                   12, "Christian, Berlin, Bruch", 13, "Climate policy, Die Grünen", 14, "Seehofer vs. Söder", 
                   15, "D.Trump", 16, "Great coalition", 17, "CDU/CSU", 18, "Elections in Niedersachen", 
                   19, "Budget statistics, Welfare policy", 20, "AfD in social media", 21, "DIE LINKE", 
                   22, "German armed forces, Mali", 23, "Nuclear Waste, Weather reports", 
                   24, "Innenministerium, Verfassungsschutz", 
                   25, "Terror attack (Amri)", 26, "G20 in Hamburg", 27, "Spahn (CDU)", 
                   28, "Steinmeier", 29, "German armed forces", 30, "AfD", 31, "Women empowerment", 
                   32, "Diplomatic relations w Turkey, Russia", 33, "Election polls", 34, "Votings in parliament", 
                   35, "F.Petri, Staatsanwaldschaft"), ncol=2, byrow=T)

topics.df <- as.data.frame(topics) %>%
  transmute(topic_name = paste(V1, V2, sep=": "),
         topic = 1:k) 
```

## Assign a topic to each document (choose by gamma)
```{r Extract wtp and dtp}
# Document-topic probabilities
stmOut %>% tidy("theta") -> theta

top_topics <- theta %>% 
  group_by(document) %>%
  mutate(therank = rank(-gamma)) %>%
  filter(therank == 1) %>%
  select(- therank)

btw.2 <- btw %>%
  mutate(document = articleID) %>%
  merge(.,top_topics, by="document") %>%
  ## Combine with Topic label
  merge(., topics.df, by="topic") %>%
  mutate(allocation = 1) 
```

### now we can inspect the unclear topics
```{r}
btw.2 %>% filter(topic==23) %>% select(title, gamma, url) %>%
  arrange(desc(gamma)) %>%
  htmlTable::htmlTable(align="l")
```

## 3.1. Topic proportions

### in the overall corpus

```{r}
frequency <- as.data.frame(colMeans(stmOut$theta)) %>% 
  mutate(frequency = colMeans(stmOut$theta),
    topic=paste(topics[,1],topics[,2], sep=": ")) 

p1 <- ggplot(frequency, aes(x=reorder(topic, frequency), y=frequency)) + 
    geom_col(fill=col[1], alpha=0.8) +
    coord_flip() +
    labs(x="", y="expected frequency") +
    theme(axis.text.x = element_text(size=8),
          axis.text.y = element_text(size=11),
          axis.title = element_text(size=10))

p1
```

Alternatively we can show the expected frequency separated by ownership:

```{r}
freq %>% left_join(., topics.df, by = "topic") %>%
  ggplot(aes(reorder(topic_name,freq), freq, fill=factor(ownership))) +
  geom_col() +
  scale_fill_manual(values = col[c(1,3)]) +
  coord_flip() +
  theme(#axis.text.y = element_blank(),
          axis.text.y = element_text(size=9),
          axis.title = element_text(size=10)) +
    labs(x="", y="Expected frequency") 
```

### by site
```{r}
plotNewspaperHistogram(11)
```

Create a Df that contains the columns means of theta (per topic and covariate level)
```{r}
freq <- tapply(stmOut$theta[,1], stmOut$settings$covariates$betaindex, mean)
freq <- as.data.frame(freq) %>% 
    mutate(site=stmOut$settings$covariates$yvarlevels,
           topic = 1)

for(i in 2:k) {
  freq1 <- tapply(stmOut$theta[,i], stmOut$settings$covariates$betaindex, mean)
  freq1 <- as.data.frame(freq1) %>% 
    transmute(site=stmOut$settings$covariates$yvarlevels,
           topic = i,
           freq = freq1)
  
  freq <- rbind(freq, freq1)
}

freq <- freq %>%
  left_join(., topics.df, by = "topic") %>%
  mutate(topic = topic_name) %>%
  left_join(., frequency %>% select(topic, frequency),
            by = "topic")
```

plots the expected proportion of topic use in public media minus the expected proportion of topic use in private media. Thus topics more associated with public media appear to the right of zero.

```{r}
ggplot(freq, aes(reorder(topic_name,frequency), freq)) +
  geom_col(fill = col[1]) +
  #scale_fill_manual(values = col[1]) +
  coord_flip() +
  facet_wrap(~site, ncol = 7)
  theme(axis.text.y = element_blank(),
          #axis.text.y = element_text(size=11),
          axis.title = element_text(size=10)) +
    labs(x="", y="difference in expected frequency (public-private)") 

p2 

# ggsave(filename = "../figs/topic_proportion.png", device = "png",width = 12, height = 10,
# dpi = 600)
```

```{r fig.height=11, fig.width=5}
topic <- 11

plotQuote(c(paste(sagelabs$cov.betas[[1]]$problabels[topic,], collapse="\n"),
            paste(sagelabs$cov.betas[[2]]$problabels[topic,], collapse="\n"),
            paste(sagelabs$cov.betas[[3]]$problabels[topic,], collapse="\n"),
            paste(sagelabs$cov.betas[[4]]$problabels[topic,], collapse="\n"),
            paste(sagelabs$cov.betas[[5]]$problabels[topic,], collapse="\n"),
            paste(sagelabs$cov.betas[[6]]$problabels[topic,], collapse="\n"),
            paste(sagelabs$cov.betas[[7]]$problabels[topic,], collapse="\n")))
```

## 3.2. Difference in topic prevalence
The estimateEffect() function explores how prevalence of topics varies across documents according to document covariates (metadata). First, users must specify the variable that they wish to use for calculating an effect. If there are multiple variables specified in estimateEffect(), then all other variables are held at their sample median. These parameters include the expected proportion of a document that belongs to a topic as a function of a covariate, or a first difference type estimate, where topic prevalence for a particular topic is contrasted for two groups.

```{r}
effect <- estimateEffect(c(1:k) ~site+s(month), stmOut, 
                         metadata = out$meta, uncertainty = "None")
```

```{r}
tables <- vector(mode="list", length = length(effect$topics))

for (i in seq_along(effect$topics)) {
  sims <- lapply(effect$parameters[[i]], function(x) stm:::rmvnorm(500, x$est, x$vcov))
  sims <- do.call(rbind, sims)
  est <- colMeans(sims)
  se <- sqrt(apply(sims,2, stats::var))
  tval <- est/se
  rdf <- nrow(effect$data) - length(est)
  p <- 2*stats::pt(abs(tval), rdf, lower.tail = FALSE)
  topic <- i
  
  coefficients <- cbind(topic, est, se, tval, p)
  rownames(coefficients) <- attr(effect$parameters[[1]][[1]]$est, "names") 
  colnames(coefficients) <- c("topic", "Estimate", "Std. Error", "t value", "p")
  tables[[i]] <- coefficients
}

out1 <- list(call=effect$call, topics=effect$topics, tables=tables)
```

```{r}
coeff <- as.data.frame(do.call(rbind,out1$tables))

coeff <- coeff %>% 
  mutate(parameter = rownames(coeff),
         parameter = gsub("site", "", parameter),
         parameter = ifelse(parameter == "s(month)1", "1_July", parameter),
         parameter = ifelse(parameter == "s(month)2", "2_August", parameter),
         parameter = ifelse(parameter == "s(month)3", "3_September", parameter),
         parameter = ifelse(parameter == "s(month)4", "4_October", parameter),
         parameter = ifelse(parameter == "s(month)5", "5_November", parameter),
         parameter = ifelse(parameter == "s(month)6", "6_December", parameter),
         signifcant = ifelse(p <= 0.5,"yes","no")) %>%
  left_join(., topics.df, by="topic")
```

```{r}

p1 <- coeff %>% 
  filter(parameter %in% stmOut$settings$covariates$yvarlevels) %>%
  ggplot(aes(x = reorder(topic_name,topic, decreasing=F), y = Estimate, fill=factor(signifcant))) +
  geom_col() +
  scale_fill_manual(values = col[c(2,1)]) +
  scale_x_discrete(position = "top") +
  coord_flip() +
  facet_wrap(~parameter, ncol = 8, scales = "free_x") +
  labs(x="", fill="significant at the 5% level") +
  theme(legend.position = "top", 
        axis.text.y = element_text(size=9),
        axis.text.x = element_text(angle=90)) 

p1

# ggsave(plot = p1, filename = "../figs/estimates.png", device = "png",width = 10, height = 7,
# dpi = 600)
```

## 3.4 Distance metric
Compute different metrices and compare them.

Compute the Jensen Shannon divergence of the word-topic probability. The K-by-V (number of words in the vocabulary) matrix logbeta contains the natural log of the probability of seeing each word conditional on the topic.

```{r}
k <- stmOut$settings$dim$K
p <- length(stmOut$settings$covariates$yvarlevels)
```

```{r}
## Find all combinations of ylevel
comb.matrix <- matrix(0, 
                      nrow= p^2, 
                      ncol = 2)

z <- 1
for (i in 1:p) {
  for (j in 1:p) {
    comb.matrix[z,1] <- stmOut$settings$covariates$yvarlevels[i]
    comb.matrix[z,2] <- stmOut$settings$covariates$yvarlevels[j]
    z <- z+1
  }
}
```

### Calculate L1 Norm
```{r}
# Create empty matrix
l1.matrix <- matrix(0, nrow = nrow(comb.matrix), ncol = k)
names(l1.matrix) <- 1:k

# Populate matrix with JSD Values
z <- 1
for (i in 1:p) {
  
    #print(paste("ylevel = ", i))
    base <- exp(stmOut$beta$logbeta[[i]])
    compare1 <- exp(stmOut$beta$logbeta[[1]])
    compare2 <- exp(stmOut$beta$logbeta[[2]])
  
  for (j in 1:k) {
    
    #print(paste("topic = ", j))
    l1.matrix[z,j] <- sum(abs(base[j,]-compare1[j,]))
    l1.matrix[z+1,j] <- sum(abs(base[j,]-compare2[j,]))

  }
    z <- z+p
}

```

```{r}
## Create DF
l1.df <- as.data.frame(l1.matrix) 
colnames(l1.df) <- 1:k

l1.df <- l1.df %>% 
  mutate(News1 = comb.matrix[,1],
         News2 = comb.matrix[,2]) %>%
  melt(.,id=c("News1","News2"), value.name="L1Norm",
       variable.name = "topic") %>%
  mutate(topic = as.integer(topic)) %>%
  left_join(., topics.df, by="topic")
```

### Calculate Cosine Similarity
```{r}
# Create empty matrix
cosine.matrix <- matrix(0, nrow = nrow(comb.matrix), ncol = k)
names(cosine.matrix) <- 1:k


# Populate matrix with JSD Values
z <- 1
for (i in 1:p) {
  
    #print(paste("ylevel = ", i))
    base <- exp(stmOut$beta$logbeta[[i]])
    compare1 <- exp(stmOut$beta$logbeta[[1]])
    compare2 <- exp(stmOut$beta$logbeta[[2]])
  
  for (j in 1:k) {
    
    #print(paste("topic = ", j))
    cosine.matrix[z,j] <- CosSim(base[j,],compare1[j,])
    cosine.matrix[z+1,j] <- CosSim(base[j,],compare2[j,])

  }
    z <- z+p
}

```

```{r}
## Create DF
cosine.df <- as.data.frame(cosine.matrix) 
colnames(cosine.df) <- 1:k

cosine.df <- cosine.df %>% 
  mutate(News1 = comb.matrix[,1],
         News2 = comb.matrix[,2]) %>%
  melt(.,id=c("News1","News2"), value.name="CosineSimilarity",
       variable.name = "topic") %>%
  mutate(topic = as.integer(topic)) %>%
  left_join(., l1.df, by=c("News1","News2","topic"))
```

### Calculate KLD
```{r}
# Create empty matrix
kld.matrix <- matrix(0, nrow = nrow(comb.matrix), ncol = k)
names(kld.matrix) <- 1:k

# Populate matrix with JSD Values
z <- 1
for (i in 1:p) {
  
    #print(paste("ylevel = ", i))
    base <- exp(stmOut$beta$logbeta[[i]])
    compare1 <- exp(stmOut$beta$logbeta[[1]])
    compare2 <- exp(stmOut$beta$logbeta[[2]])
  
  for (j in 1:k) {
    
    #print(paste("topic = ", j))
    kld.matrix[z,j] <- KLD(base[j,],compare1[j,])
    kld.matrix[z+1,j] <- KLD(base[j,],compare2[j,])

  }
    z <- z+p
}
```

```{r}
## Create DF
kld.df <- as.data.frame(kld.matrix) 
colnames(kld.df) <- 1:k

kld.df <- kld.df %>% mutate(News1 = comb.matrix[,1],
         News2 = comb.matrix[,2]) %>%
  melt(.,id=c("News1","News2"), value.name="KLD",
       variable.name = "topic") %>%
  mutate(topic = as.integer(topic)) %>%
  left_join(., cosine.df, by=c("News1","News2","topic"))
```

### Calculate JSD
```{r}
# Create empty matrix
jsd.matrix <- matrix(0, nrow = nrow(comb.matrix), ncol = k)
names(jsd.matrix) <- 1:k

# Populate matrix with JSD Values
z <- 1
for (i in 1:p) {
  
    #print(paste("ylevel = ", i))
    base <- exp(stmOut$beta$logbeta[[i]])
    compare1 <- exp(stmOut$beta$logbeta[[1]])
    compare2 <- exp(stmOut$beta$logbeta[[2]])
  
  for (j in 1:k) {
    
    #print(paste("topic = ", j))
    jsd.matrix[z,j] <- JSD(base[j,],compare1[j,])
    jsd.matrix[z+1,j] <- JSD(base[j,],compare2[j,])

  }
    z <- z+p
}
```

```{r}
## Create DF
jsd.df <- as.data.frame(jsd.matrix) 
colnames(jsd.df) <- 1:k

distance.df <- jsd.df %>% mutate(News1 = comb.matrix[,1],
         News2 = comb.matrix[,2]) %>% 
  melt(.,id=c("News1","News2"), value.name="JSD",
       variable.name = "topic") %>%
  mutate(topic = as.integer(topic)) %>%
  left_join(., kld.df, by=c("News1","News2","topic")) 

rm(l1.df, jsd.df, cosine.df, kld.df)
```

### Plot 
```{r}
cols <- rev(brewer.pal(11, 'RdYlBu'))


p1 <- distance.df %>%
  filter(!topic %in% c("11","15")) %>%
  filter(News1!=News2) %>%
  filter(News1=="private") %>%
  ggplot(aes(News1, reorder(factor(topic_name),JSD), fill = JSD)) + 
  geom_tile() +
  scale_fill_gradientn(colours = cols) +
  labs(x="", y="") +
  theme_bw(base_family = "Roboto", base_size = 11) +
  theme(axis.text.x = element_blank(),
        legend.position = "top",
        plot.background = element_rect(fill = 'transparent', colour = 'transparent'),
        strip.background = element_rect(fill = 'transparent', colour = 'transparent'),
        axis.ticks = element_line(colour = 'transparent'))

p2 <- distance.df %>%
  filter(!topic %in% c("11","15")) %>%
  filter(News1!=News2) %>%
  ggplot(aes(News1, reorder(factor(topic_name),JSD), fill = KLD)) + 
  geom_tile() +
  scale_fill_gradientn(colours = cols) +
  labs(x="", y="") +
  theme_bw(base_family = "Roboto", base_size = 11) +
  theme(axis.text.y = element_blank(),
        legend.position = "top",
        plot.background = element_rect(fill = 'transparent', colour = 'transparent'),
        strip.background = element_rect(fill = 'transparent', colour = 'transparent'),
        axis.ticks = element_line(colour = 'transparent'))

p3 <- distance.df %>%
  filter(!topic %in% c("11","15")) %>%
  filter(News1!=News2) %>%
  filter(News1=="private") %>%
  ggplot(aes(News1, reorder(factor(topic_name),JSD), 
             fill = CosineSimilarity)) + 
  geom_tile() +
  scale_fill_gradientn(colours = cols) +
  labs(x="", y="") +
  theme_bw(base_family = "Roboto", base_size = 11) +
  theme(axis.text = element_blank(),
        legend.position = "top",
        plot.background = element_rect(fill = 'transparent', colour = 'transparent'),
        strip.background = element_rect(fill = 'transparent', colour = 'transparent'),
        axis.ticks = element_line(colour = 'transparent'))

p4 <- distance.df %>%
  filter(!topic %in% c("11","15")) %>%
  filter(News1!=News2) %>%
  filter(News1=="private") %>%
  ggplot(aes(News1, reorder(factor(topic_name),JSD), 
             fill = L1Norm)) + 
  geom_tile() +
  scale_fill_gradientn(colours = cols) +
  labs(x="", y="") +
  theme_bw(base_family = "Roboto", base_size = 11) +
  theme(axis.text = element_blank(),
        legend.position = "top",
        plot.background = element_rect(fill = 'transparent', colour = 'transparent'),
        strip.background = element_rect(fill = 'transparent', colour = 'transparent'),
        axis.ticks = element_line(colour = 'transparent'))

(p1 | p2 | p3 | p4 )

ggsave(filename = "../figs/distance.png", device = "png",width = 12, height = 8,
dpi = 600)
```

## Sentiment analysis

```{r}
sent <- c(
  # positive Wörter
  readLines("dict/SentiWS_v1.8c_Negative.txt",
            encoding = "UTF-8"),
  # negative Wörter
  readLines("dict/SentiWS_v1.8c_Positive.txt",
            encoding = "UTF-8")
) %>% lapply(function(x) {
  # Extrahieren der einzelnen Spalten
  res <- strsplit(x, "\t", fixed = TRUE)[[1]]
  return(data.frame(words = res[1], value = res[2],
                    stringsAsFactors = FALSE))
}) %>%
  bind_rows %>% 
  mutate(word = gsub("\\|.*", "", words) %>% tolower,
         value = as.numeric(value)) %>% 
  # manche Wörter kommen doppelt vor, hier nehmen wir den mittleren Wert
  group_by(word) %>% summarise(value = mean(value)) %>% ungroup
```

Apply the dictionary on the artciles

```{r, message=FALSE, warning=FALSE, include=FALSE}
# Tokenize text
token <- btw.2 %>%
  unnest_tokens(word, text)

# Combine with sentiment values
sentDF <- left_join(token, sent, by="word") %>% 
  mutate(sentiment = as.numeric(value)) %>% 
  filter(!is.na(sentiment)) 
```

Calculate the number of total articles to weight the senitiment value. 

```{r}
sentDF.red <- sentDF %>%
  
  # Count number of articles by medium
  group_by(site) %>% 
  add_tally() %>%
  ungroup() %>%
  mutate(totalcount = n) %>%
  select(-n) %>%
  
  # count number of articles by medium and topic
  group_by(site, topic_name) %>%
  add_tally() %>%
  ungroup() %>%
  mutate(count = n) %>%
  mutate(weight = count/totalcount) %>%
  
  # calculate weight and weighted sentiment score
  group_by(site, topic_name) %>%
  summarize(sent_value = mean(sentiment),
            weight = mean(weight)) %>%
  mutate(weighted = sent_value*weight)
```

### Plot Sentiment

Unweighted
```{r fig.height=12}
sentDF.red %>%
  ggplot(aes(topic_name, sent_value)) +
  geom_col(fill=col[3], alpha=0.8) +
  coord_flip() +
  facet_wrap(~site, ncol = 7) +
  labs(x="", y="sentiment value") +
  theme(axis.text.x = element_text(size=10, angle = 90))

ggsave(filename = "../figs/sentiment.png", device = "png",width = 12, height = 8,
dpi = 600)
```

weighted
```{r fig.height=12}
sentDF.red %>%
  ggplot(aes(topic_name, weighted)) +
  geom_col(fill=col[3], alpha=0.8) +
  coord_flip() +
  facet_wrap(~site, ncol = 7) +
  labs(x="", y="sentiment value") +
  theme(axis.text.x = element_text(size=10, angle = 90))

ggsave(filename = "../figs/sent_weighted.png", device = "png",width = 12, height = 8,
dpi = 600)
```

### Radar plot
```{r}
library(radarchart)
```

```{r}
sentDF.red %>% 
  select(site, topic_name, sent_value) %>%
  spread(key=site, value=sent_value) %>%
  ungroup() -> radar
```

```{r}
chartJSRadar(scores = radar, labelSize = 8, 
             scaleStartValue = -0.15,
             maxScale = 0, 
             showToolTipLabel = TRUE,
             width = 8, height = 8)
```

